<h1>dcv.imgproc.color</h1>
           <br><br>
<dl><dt><big><a name="Rgb2GrayConvertion"></a>enum <u>Rgb2GrayConvertion</u>: int;
</big></dt>
<dd>RGB to Grayscale convertion strategy.<br><br>

<dl><dt><big><a name="Rgb2GrayConvertion.MEAN"></a><u>MEAN</u></big></dt>
<dd>Mean the RGB values and assign to gray.<br><br>

</dd>
<dt><big><a name="Rgb2GrayConvertion.LUMINANCE_PRESERVE"></a><u>LUMINANCE_PRESERVE</u></big></dt>
<dd>Use luminance preservation (0.2126R + 0.715G + 0.0722B).<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="rgb2gray"></a>pure nothrow Slice!(2, V*) <u>rgb2gray</u>(V)(Slice!(3, V*) <i>range</i>, Slice!(2, V*) <i>prealloc</i> = emptySlice!(2, V), Rgb2GrayConvertion <i>conv</i> = Rgb2GrayConvertion.LUMINANCE_PRESERVE);
</big></dt>
<dd>Convert RGB image to grayscale.
<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(3, V*) <i>range</i></td>
<td>Input image <i>range</i>. Should have 3 channels, represented
 as R, G and B respectivelly in that order.</td></tr>
<tr><td>Slice!(2, V*) <i>prealloc</i></td>
<td>Pre-allocated <i>range</i>, where grayscale image will be copied. Default
 argument is an empty slice, where new data is allocated and returned. If given
 slice is not of corresponding shape(<i>range</i>.shape[0], <i>range</i>.shape[1]), it is
 discarded and allocated anew.</td></tr>
<tr><td>Rgb2GrayConvertion <i>conv</i></td>
<td>Convertion strategy - mean, or luminance preservation.</td></tr>
</table><br>
<b>return:</b><br>
Returns grayscale version of the given RGB image, of the same size.<br><br>

</dd>
<dt><big><a name="bgr2gray"></a>pure nothrow Slice!(2, V*) <u>bgr2gray</u>(V)(Slice!(3, V*) <i>range</i>, Slice!(2, V*) <i>prealloc</i> = emptySlice!(2, V), Rgb2GrayConvertion <i>conv</i> = Rgb2GrayConvertion.LUMINANCE_PRESERVE);
</big></dt>
<dd>Convert BGR image to grayscale.
<br><br>
Same as rgb2gray, but follows swapped channels if luminance preservation
 is chosen as convertion strategy.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(3, V*) <i>range</i></td>
<td>Input image <i>range</i>. Should have 3 channels, represented
 as B, G and R respectivelly in that order.</td></tr>
<tr><td>Slice!(2, V*) <i>prealloc</i></td>
<td>Pre-allocated <i>range</i>, where grayscale image will be copied. Default
 argument is an empty slice, where new data is allocated and returned. If given
 slice is not of corresponding shape(<i>range</i>.shape[0], <i>range</i>.shape[1]), it is
 discarded and allocated anew.</td></tr>
<tr><td>Rgb2GrayConvertion <i>conv</i></td>
<td>Convertion strategy - mean, or luminance preservation.</td></tr>
</table><br>
<b>return:</b><br>
Returns grayscale version of the given BGR image, of the same size.<br><br>

</dd>
<dt><big><a name="gray2rgb"></a>pure nothrow Slice!(3, V*) <u>gray2rgb</u>(V)(Slice!(2, V*) <i>range</i>, Slice!(3, V*) <i>prealloc</i> = emptySlice!(3, V));
</big></dt>
<dd>Convert gray image to RGB.
<br><br>
Uses grayscale value and assigns it's value
 to each of three channels for the RGB image version.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(2, V*) <i>range</i></td>
<td>Grayscale image version, to be converted to the RGB.</td></tr>
<tr><td>Slice!(3, V*) <i>prealloc</i></td>
<td>Pre-allocated <i>range</i>, where RGB image will be copied. Default
 argument is an empty slice, where new data is allocated and returned. If given
 slice is not of corresponding shape(<i>range</i>.shape[0], <i>range</i>.shape[1], 3), it is
 discarded and allocated anew.</td></tr>
</table><br>
<b>return:</b><br>
Returns RGB version of the given grayscale image.<br><br>

</dd>
<dt><big><a name="rgb2hsv"></a>Slice!(3, R*) <u>rgb2hsv</u>(R, V)(Slice!(3, V*) <i>range</i>, Slice!(3, R*) <i>prealloc</i> = emptySlice!(3, R)) if (isNumeric!R &amp;&amp; isNumeric!V);
</big></dt>
<dd>Convert RGB image to HSV color format.
<br><br>
If HSV is represented as floating point, H is
 represented as 0-360 (degrees), S and V are 0.0-1.0.
 If is integral, S, and V are 0-100.
<br><br>

 Depending on the RGB (input) type, values are treated in the
 algorithm to be ranged as 0-255 for ubyte, 0-65535 for ushort,
 and 0-1 for floating point types.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(3, V*) <i>range</i></td>
<td>RGB image version, which gets converted to HVS.</td></tr>
<tr><td>Slice!(3, R*) <i>prealloc</i></td>
<td>Pre-allocated <i>range</i>, where HSV image will be copied. Default
 argument is an empty slice, where new data is allocated and returned. If given
 slice is not of corresponding shape(<i>range</i>.shape[0], <i>range</i>.shape[1], 3), it is
 discarded and allocated anew.</td></tr>
</table><br>
<b>return:</b><br>
Returns HSV verion of the given RGB image.<br><br>

</dd>
<dt><big><a name="hsv2rgb"></a>Slice!(3, R*) <u>hsv2rgb</u>(R, V)(Slice!(3, V*) <i>range</i>, Slice!(3, R*) <i>prealloc</i> = emptySlice!(3, R)) if (isNumeric!R &amp;&amp; isNumeric!V);
</big></dt>
<dd>Convert HSV image to RGB color format.
<br><br>
HSV is represented in floating point, where
 H is 0-360 degrees, S and V is 0.0-1.0.
<br><br>

 Output <i>range</i> values are based on the output type cast - ubyte will
 <i>range</i> RGB values to be 0-255, ushort 0-65535, and floating types
 0.0-1.0. Other types are not supported.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(3, V*) <i>range</i></td>
<td>RGB image version, which gets converted to HVS.</td></tr>
<tr><td>Slice!(3, R*) <i>prealloc</i></td>
<td>Pre-allocated <i>range</i>, where HSV image will be copied. Default
 argument is an empty slice, where new data is allocated and returned. If given
 slice is not of corresponding shape(<i>range</i>.shape[0], <i>range</i>.shape[1], 3), it is
 discarded and allocated anew.</td></tr>
</table><br>
<b>return:</b><br>
Returns HSV verion of the given RGB image.<br><br>

</dd>
<dt><big><a name="rgb2yuv"></a>Slice!(3, V*) <u>rgb2yuv</u>(V)(Slice!(3, V*) <i>range</i>, Slice!(3, V*) <i>prealloc</i> = emptySlice!(3, V));
</big></dt>
<dd>Convert RGB image format to YUV.
<br><br>
YUV images in dcv are organized in the same buffer plane
 where quantity of luma and chroma values are the same (as in
 YUV444 format).<br><br>

</dd>
<dt><big><a name="yuv2rgb"></a>Slice!(3, V*) <u>yuv2rgb</u>(V)(Slice!(3, V*) <i>range</i>, Slice!(3, V*) <i>prealloc</i> = emptySlice!(3, V));
</big></dt>
<dd>Convert YUV image to RGB.
<br><br>
As in rgb2yuv conversion, YUV format is considered to have
 same amount of luma and chroma.

<br><br>
<b>TODO:</b><br>
Separate inupt and output type as in rgb2hsv etc.<br><br>

</dd>
</dl>

           <hr>
