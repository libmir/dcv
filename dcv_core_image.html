<h1>dcv.core.image</h1>
           Module implements Image utility class, and basic API for <u id="image">image</u> manipulation.
<br><br>
<b>Authors:</b><br>
Relja Ljubobratovic

<br><br>
<b>License:</b><br>
<a target="_blank" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License - Version 1.0</a>.<br><br>

<dl><dt><big><a name="ImageFormat"></a>enum <u id="ImageFormat">ImageFormat</u>: int;
</big></dt>
<dd>Image (pixel) format.<br><br>

</dd>
<dt><big><a name="BitDepth"></a>enum <u id="BitDepth">BitDepth</u>: ulong;
</big></dt>
<dd>Bit depth of a pixel in an image.<br><br>

</dd>
<dt><big><a name="Image"></a>class <u id="Image">Image</u>;
</big></dt>
<dd><u id="Image">Image</u> abstraction type.<br><br>

<dl><dt><big><a name="Image.this"></a>pure nothrow @safe this();
</big></dt>
<dd>Default constructor for image.
<br><br>
Creates an empty image structure.<br><br>

</dd>
<dt><big><a name="Image.this.2"></a>pure this(in Image <i>copy</i>, bool <i>deepCopy</i> = false);
</big></dt>
<dd>Copy constructor.
<br><br>
<b>Params:</b><br>
<table><tr><td>Image <i>copy</i></td>
<td>Input image, which is copied into this image structure.</td></tr>
<tr><td>bool <i>deepCopy</i></td>
<td>if <b>false</b> (default) the data array will be referenced
 from <i>copy</i>, esle values will be copied to newly allocated array.</td></tr>
</table><br>

</dd>
<dt><big><a name="Image.this.3"></a>pure nothrow @safe this(size_t <i>width</i>, size_t <i>height</i>, ImageFormat <i>format</i> = ImageFormat.IF_RGB, BitDepth <i>depth</i> = BitDepth.BD_8, ubyte[] <i>data</i> = null);
</big></dt>
<dd>Construct an image by given size, <i>format</i> and bit <i>depth</i> information.
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>width</i></td>
<td><i>width</i> of a newly created image.</td></tr>
<tr><td>size_t <i>height</i></td>
<td><i>height</i> of a newly created image.</td></tr>
<tr><td>ImageFormat <i>format</i></td>
<td><i>format</i> of a newly created image.</td></tr>
<tr><td>BitDepth <i>depth</i></td>
<td>bit <i>depth</i> of a newly created image.</td></tr>
<tr><td>ubyte[] <i>data</i></td>
<td>potential <i>data</i> of an image, pre-allocated. If not a <b>null</b>, <i>data</i> array
 has to be of correct size = <i>width</i>*<i>height</i>*channels*<i>depth</i>, where channels are
 defined by the <i>format</i>, and <i>depth</i> is counded in bytes.</td></tr>
</table><br>

</dd>
<dt><big><a name="Image.format"></a>const pure @property @safe auto <u id="format">format</u>();
</big></dt>
<dd>Get <u id="format">format</u> of an image.<br><br>

</dd>
<dt><big><a name="Image.width"></a>const pure @property @safe auto <u id="width">width</u>();
</big></dt>
<dd>Get height of an image.<br><br>

</dd>
<dt><big><a name="Image.height"></a>const pure @property @safe auto <u id="height">height</u>();
</big></dt>
<dd>Get <u id="height">height</u> of an image.<br><br>

</dd>
<dt><big><a name="Image.depth"></a>const pure @property @safe auto <u id="depth">depth</u>();
</big></dt>
<dd>Get bit <u id="depth">depth</u> of the image.<br><br>

</dd>
<dt><big><a name="Image.empty"></a>const pure @property @safe auto <u id="empty">empty</u>();
</big></dt>
<dd>Check if image is <u id="empty">empty</u> (there's no data present).<br><br>

</dd>
<dt><big><a name="Image.channels"></a>const pure @property @safe auto <u id="channels">channels</u>();
</big></dt>
<dd>Channel count of the image.<br><br>

</dd>
<dt><big><a name="Image.pixelSize"></a>const pure @property @safe auto <u id="pixelSize">pixelSize</u>();
</big></dt>
<dd>Number of bytes contained in one pixel of the image.<br><br>

</dd>
<dt><big><a name="Image.byteSize"></a>const pure @property @safe auto <u id="byteSize">byteSize</u>();
</big></dt>
<dd>Number of bytes contained in the image.<br><br>

</dd>
<dt><big><a name="Image.rowStride"></a>const pure @property @safe auto <u id="rowStride">rowStride</u>();
</big></dt>
<dd>Number of bytes contained in one row of the image.<br><br>

</dd>
<dt><big><a name="Image.size"></a>const pure @property @safe size_t[3] <u id="size">size</u>();
</big></dt>
<dd>Size of the image.
<br><br>
Returns an array of 3 sizes: [width, height, channels]<br><br>

</dd>
<dt><big><a name="Image.isOfType"></a>const pure nothrow @safe bool <u id="isOfType">isOfType</u>(T)();
</big></dt>
<dd>Check if this images data corresponds to given value type.
<br><br>
Given value type is checked against the image data bit depth.
 Data of 8-bit image is considered to be typed as ubyte array,
 16-bit as ushort, and 32-bit as float array. Any other type as
 input returns <b>false</b> result.

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>(template parameter) value type which is tested against the bit depth of the image data.</td></tr>
</table><br>

</dd>
<dt><big><a name="Image.asType"></a>inout auto <u id="asType">asType</u>(T)();
</big></dt>
<dd>Convert image data type to given type.
<br><br>
Creates new image with data typed as given value type.
 If this image's data type is the same as given type, deep
 copy of this image is returned.

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>(template parameter) value type to which image's data is converted.</td></tr>
</table><br>
<b>return:</b><br>
Copy of this image with casted data to given type. If given type is same as
 current data of this image, deep copy is returned.<br><br>

</dd>
<dt><big><a name="Image.data"></a>inout pure auto <u id="data">data</u>(T = ubyte)();
</big></dt>
<dd>Get <u id="data">data</u> array from this image.
<br><br>
Cast <u id="data">data</u> array to corresponding dynamic array type,
 and return it.
 8-bit <u id="data">data</u> is considered ubyte, 16-bit ushort, and 32-bit float.

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>(template parameter) value type (default ubyte) to which <u id="data">data</u> array is casted to.</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="asImage"></a>Image <u id="asImage">asImage</u>(size_t N, T)(Slice!(N, T*) <i>slice</i>, ImageFormat <i>format</i>);
</big></dt>
<dd>Convert a ndslice object to an Image, with defined image <i>format</i>.<br><br>

</dd>
<dt><big><a name="asImage.2"></a>Image <u id="asImage">asImage</u>(size_t N, T)(Slice!(N, T*) <i>slice</i>);
</big></dt>
<dd>Convert ndslice object into an image, with default format setup, regarding to <i>slice</i> dimension.<br><br>

</dd>
</dl>

           <hr>Copyright Relja Ljubobratovic 2016.


